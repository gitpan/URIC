/*
 * FILE : URIC_wrap.c
 * 
 * This file was automatically generated by :
 * Simplified Wrapper and Interface Generator (SWIG)
 * Version 1.1 (Patch 5)
 * 
 * Portions Copyright (c) 1995-1998
 * The University of Utah and The Regents of the University of California.
 * Permission is granted to distribute this file in any manner provided
 * this notice remains intact.
 * 
 * Do not make changes to this file--changes will be lost!
 *
 */


#define SWIGCODE
/* Implementation : PERL 5 */

#define SWIGPERL
#define SWIGPERL5
#ifdef __cplusplus
#include <math.h>
#include <stdlib.h>
extern "C" {
#endif
#include "EXTERN.h"
#include "perl.h"
#include "XSUB.h"
#undef free
#undef malloc
#include <string.h>
#ifdef __cplusplus
}
#endif
/* Definitions for compiling Perl extensions on a variety of machines */

#if defined(WIN32) || defined(__WIN32__)
#   if defined(_MSC_VER)
#	define SWIGEXPORT(a,b) __declspec(dllexport) a b
#   else
#	if defined(__BORLANDC__)
#	    define SWIGEXPORT(a,b) a _export b
#	else
#	    define SWIGEXPORT(a,b) a b
#	endif
#   endif
#else
#   define SWIGEXPORT(a,b) a b
#endif

#ifdef PERL_OBJECT
#define MAGIC_PPERL  CPerl *pPerl = (CPerl *) this;
#define MAGIC_CAST   (int (CPerl::*)(SV *, MAGIC *))
#define SWIGCLASS_STATIC 
#else
#define MAGIC_PPERL
#define MAGIC_CAST
#define SWIGCLASS_STATIC static
#endif


/*****************************************************************************
 * $Header: /home/beazley/SWIG/SWIG1.1b3/swig_lib/perl5/RCS/perl5ptr.swg,v 1.1 1996/12/26 22:17:29 beazley Exp beazley $
 *
 * perl5ptr.swg
 *
 * This file contains supporting code for the SWIG run-time type checking
 * mechanism.  The following functions are available :
 *
 * SWIG_RegisterMapping(char *origtype, char *newtype, void *(*cast)(void *));
 *
 *      Registers a new type-mapping with the type-checker.  origtype is the
 *      original datatype and newtype is an equivalent type.  cast is optional
 *      pointer to a function to cast pointer values between types (this
 *      is only used to cast pointers from derived classes to base classes in C++)
 *      
 * SWIG_MakePtr(char *buffer, void *ptr, char *typestring);
 *     
 *      Makes a pointer string from a pointer and typestring.  The result is returned
 *      in buffer.
 *
 * char * SWIG_GetPtr(SV *obj, void **ptr, char *type)
 *
 *      Gets a pointer value from a Perl5 scalar value.  If there is a 
 *      type-mismatch, returns a character string to the received type.  
 *      On success, returns NULL.
 *
 *
 * You can remap these functions by making a file called "swigptr.swg" in
 * your the same directory as the interface file you are wrapping.
 *
 * These functions are normally declared static, but this file can be
 * can be used in a multi-module environment by redefining the symbol
 * SWIGSTATIC.
 *
 * $Log: perl5ptr.swg,v $
 * Revision 1.1  1996/12/26 22:17:29  beazley
 * Initial revision
 *
 *****************************************************************************/

#include <stdlib.h>

#ifdef SWIG_GLOBAL
#ifdef __cplusplus
#define SWIGSTATIC extern "C"
#else
#define SWIGSTATIC
#endif
#endif

#ifndef SWIGSTATIC
#define SWIGSTATIC static
#endif

/* These are internal variables.   Should be static */

typedef struct SwigPtrType {
  char               *name;
  int                 len;
  void               *(*cast)(void *);
  struct SwigPtrType *next;
} SwigPtrType;

/* Pointer cache structure */

typedef struct {
  int                 stat;               /* Status (valid) bit             */
  SwigPtrType        *tp;                 /* Pointer to type structure      */
  char                name[256];          /* Given datatype name            */
  char                mapped[256];        /* Equivalent name                */
} SwigCacheType;

static int SwigPtrMax  = 64;           /* Max entries that can be currently held */
static int SwigPtrN    = 0;            /* Current number of entries              */
static int SwigPtrSort = 0;            /* Status flag indicating sort            */
static SwigPtrType *SwigPtrTable = 0;  /* Table containing pointer equivalences  */
static int SwigStart[256];             /* Table containing starting positions    */

/* Cached values */

#define SWIG_CACHESIZE  8
#define SWIG_CACHEMASK  0x7
static SwigCacheType SwigCache[SWIG_CACHESIZE];  
static int SwigCacheIndex = 0;
static int SwigLastCache = 0;

/* Sort comparison function */
static int swigsort(const void *data1, const void *data2) {
	SwigPtrType *d1 = (SwigPtrType *) data1;
	SwigPtrType *d2 = (SwigPtrType *) data2;
	return strcmp(d1->name,d2->name);
}

/* Binary Search function */
static int swigcmp(const void *key, const void *data) {
  char *k = (char *) key;
  SwigPtrType *d = (SwigPtrType *) data;
  return strncmp(k,d->name,d->len);
}

/* Register a new datatype with the type-checker */

#ifndef PERL_OBJECT
SWIGSTATIC 
void SWIG_RegisterMapping(char *origtype, char *newtype, void *(*cast)(void *)) {
#else
SWIGSTATIC
#define SWIG_RegisterMapping(a,b,c) _SWIG_RegisterMapping(pPerl, a,b,c)
void _SWIG_RegisterMapping(CPerl *pPerl, char *origtype, char *newtype, void *(*cast)(void *)) {
#endif

  int i;
  SwigPtrType *t = 0, *t1;

  if (!SwigPtrTable) {     
    SwigPtrTable = (SwigPtrType *) malloc(SwigPtrMax*sizeof(SwigPtrType));
    SwigPtrN = 0;
  }
  if (SwigPtrN >= SwigPtrMax) {
    SwigPtrMax = 2*SwigPtrMax;
    SwigPtrTable = (SwigPtrType *) realloc(SwigPtrTable,SwigPtrMax*sizeof(SwigPtrType));
  }
  for (i = 0; i < SwigPtrN; i++)
    if (strcmp(SwigPtrTable[i].name,origtype) == 0) {
      t = &SwigPtrTable[i];
      break;
    }
  if (!t) {
    t = &SwigPtrTable[SwigPtrN];
    t->name = origtype;
    t->len = strlen(t->name);
    t->cast = 0;
    t->next = 0;
    SwigPtrN++;
  }
  while (t->next) {
    if (strcmp(t->name,newtype) == 0) {
      if (cast) t->cast = cast;
      return;
    }
    t = t->next;
  }
  t1 = (SwigPtrType *) malloc(sizeof(SwigPtrType));
  t1->name = newtype;
  t1->len = strlen(t1->name);
  t1->cast = cast;
  t1->next = 0;
  t->next = t1;
  SwigPtrSort = 0;
}

/* Make a pointer value string */

SWIGSTATIC 
void SWIG_MakePtr(char *_c, const void *_ptr, char *type) {
  static char _hex[16] =
  {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
   'a', 'b', 'c', 'd', 'e', 'f'};
  unsigned long _p, _s;
  char _result[20], *_r;    /* Note : a 64-bit hex number = 16 digits */
  _r = _result;
  _p = (unsigned long) _ptr;
  if (_p > 0) {
    while (_p > 0) {
      _s = _p & 0xf;
      *(_r++) = _hex[_s];
      _p = _p >> 4;
    }
    *_r = '_';
    while (_r >= _result)
      *(_c++) = *(_r--);
  } else {
    strcpy (_c, "NULL");
  }
  if (_ptr)
    strcpy (_c, type);
}

/* Define for backwards compatibility */

#define _swig_make_hex   SWIG_MakePtr 

/* Function for getting a pointer value */

#ifndef PERL_OBJECT
SWIGSTATIC 
char *SWIG_GetPtr(SV *sv, void **ptr, char *_t)
#else
SWIGSTATIC
#define SWIG_GetPtr(a,b,c) _SWIG_GetPtr(pPerl,a,b,c)
char *_SWIG_GetPtr(CPerl *pPerl, SV *sv, void **ptr, char *_t)
#endif
{
  char temp_type[256];
  char *name,*_c;
  int  len,i,start,end;
  IV   tmp;
  SwigPtrType *sp,*tp;
  SwigCacheType *cache;

  /* If magical, apply more magic */

  if (SvGMAGICAL(sv))
    mg_get(sv);

  /* Check to see if this is an object */
  if (sv_isobject(sv)) {
    SV *tsv = (SV*) SvRV(sv);
    if ((SvTYPE(tsv) == SVt_PVHV)) {
      MAGIC *mg;
      if (SvMAGICAL(tsv)) {
	mg = mg_find(tsv,'P');
	if (mg) {
	  SV *rsv = mg->mg_obj;
	  if (sv_isobject(rsv)) {
	    tmp = SvIV((SV*)SvRV(rsv));
	  }
	}
      } else {
	return "Not a valid pointer value";
      }
    } else {
      tmp = SvIV((SV*)SvRV(sv));
    }
    if (!_t) {
      *(ptr) = (void *) tmp;
      return (char *) 0;
    }
  } else if (sv == &sv_undef) {            /* Check for undef */
    *(ptr) = (void *) 0;
    return (char *) 0;
  } else if (SvTYPE(sv) == SVt_RV) {       /* Check for NULL pointer */
    *(ptr) = (void *) 0;
    if (!SvROK(sv)) 
      return (char *) 0;
    else
      return "Not a valid pointer value";
  } else {                                 /* Don't know what it is */
      *(ptr) = (void *) 0;
      return "Not a valid pointer value";
  }
  if (_t) {
    /* Now see if the types match */      

    if (!sv_isa(sv,_t)) {
      _c = HvNAME(SvSTASH(SvRV(sv)));
      if (!SwigPtrSort) {
	qsort((void *) SwigPtrTable, SwigPtrN, sizeof(SwigPtrType), swigsort);  
	for (i = 0; i < 256; i++) {
	  SwigStart[i] = SwigPtrN;
	}
	for (i = SwigPtrN-1; i >= 0; i--) {
	  SwigStart[SwigPtrTable[i].name[0]] = i;
	}
	for (i = 255; i >= 1; i--) {
	  if (SwigStart[i-1] > SwigStart[i])
	    SwigStart[i-1] = SwigStart[i];
	}
	SwigPtrSort = 1;
	for (i = 0; i < SWIG_CACHESIZE; i++)  
	  SwigCache[i].stat = 0;
      }
      /* First check cache for matches.  Uses last cache value as starting point */
      cache = &SwigCache[SwigLastCache];
      for (i = 0; i < SWIG_CACHESIZE; i++) {
	if (cache->stat) {
	  if (strcmp(_t,cache->name) == 0) {
	    if (strcmp(_c,cache->mapped) == 0) {
	      cache->stat++;
	      *ptr = (void *) tmp;
	      if (cache->tp->cast) *ptr = (*(cache->tp->cast))(*ptr);
	      return (char *) 0;
	    }
	  }
	}
	SwigLastCache = (SwigLastCache+1) & SWIG_CACHEMASK;
	if (!SwigLastCache) cache = SwigCache;
	else cache++;
      }

      start = SwigStart[_t[0]];
      end = SwigStart[_t[0]+1];
      sp = &SwigPtrTable[start];
      while (start < end) {
	if (swigcmp(_t,sp) == 0) break;
	sp++;
	start++;
      }
      if (start >= end) sp = 0;
      if (sp) {
	while (swigcmp(_t,sp) == 0) {
	  name = sp->name;
	  len = sp->len;
	  tp = sp->next;
	  while(tp) {
	    if (tp->len >= 255) {
	      return _c;
	    }
	    strcpy(temp_type,tp->name);
	    strncat(temp_type,_t+len,255-tp->len);
	    if (sv_isa(sv,temp_type)) {
	      /* Get pointer value */
	      *ptr = (void *) tmp;
	      if (tp->cast) *ptr = (*(tp->cast))(*ptr);

	      strcpy(SwigCache[SwigCacheIndex].mapped,_c);
	      strcpy(SwigCache[SwigCacheIndex].name,_t);
	      SwigCache[SwigCacheIndex].stat = 1;
	      SwigCache[SwigCacheIndex].tp = tp;
	      SwigCacheIndex = SwigCacheIndex & SWIG_CACHEMASK;
	      return (char *) 0;
	    }
	    tp = tp->next;
	  } 
	  /* Hmmm. Didn't find it this time */
 	  sp++;
	}
      }
      /* Didn't find any sort of match for this data.  
	 Get the pointer value and return the received type */
      *ptr = (void *) tmp;
      return _c;
    } else {
      /* Found a match on the first try.  Return pointer value */
      *ptr = (void *) tmp;
      return (char *) 0;
    }
  } 
  *ptr = (void *) tmp;
  return (char *) 0;
}

/* Compatibility mode */

#define _swig_get_hex  SWIG_GetPtr
/* Magic variable code */
#ifndef PERL_OBJECT
#define swig_create_magic(s,a,b,c) _swig_create_magic(s,a,b,c)
static void _swig_create_magic(SV *sv, char *name, int (*set)(SV *, MAGIC *), int (*get)(SV *,MAGIC *)) {
#else
#define swig_create_magic(s,a,b,c) _swig_create_magic(pPerl,s,a,b,c)
static void _swig_create_magic(CPerl *pPerl, SV *sv, char *name, int (CPerl::*set)(SV *, MAGIC *), int (CPerl::*get)(SV *, MAGIC *)) {
#endif
  MAGIC *mg;
  sv_magic(sv,sv,'U',name,strlen(name));
  mg = mg_find(sv,'U');
  mg->mg_virtual = (MGVTBL *) malloc(sizeof(MGVTBL));
  mg->mg_virtual->svt_get = get;
  mg->mg_virtual->svt_set = set;
  mg->mg_virtual->svt_len = 0;
  mg->mg_virtual->svt_clear = 0;
  mg->mg_virtual->svt_free = 0;
}

#define SWIG_init    boot_URIC

#define SWIG_name   "URICc::boot_URIC"
#define SWIG_varinit "URICc::var_URIC_init();"
#ifdef __cplusplus
extern "C"
#endif
#ifndef PERL_OBJECT
SWIGEXPORT(void,boot_URIC)(CV* cv);
#else
SWIGEXPORT(void,boot_URIC)(CPerl *, CV *cv);
#endif

#include "urilib/uri.h"
#ifndef PERL_OBJECT
#define swig_setiv(a,b) _swig_setiv(a,b)
static void _swig_setiv(char *name, long value) { 
#else
#define swig_setiv(a,b) _swig_setiv(pPerl,a,b)
static void _swig_setiv(CPerl *pPerl, char *name, long value) { 
#endif
     SV *sv; 
     sv = perl_get_sv(name,TRUE | 0x2);
     sv_setiv(sv, (IV) value);
     SvREADONLY_on(sv);
}

#ifndef PERL_OBJECT
#define swig_setpv(a,b) _swig_setpv(a,b)
static void _swig_setpv(char *name, char *value) { 
#else
#define swig_setpv(a,b) _swig_setpv(pPerl,a,b)
static void _swig_setpv(CPerl *pPerl, char *name, char *value) { 
#endif
     SV *sv; 
     sv = perl_get_sv(name,TRUE | 0x2);
     sv_setpv(sv, value);
     SvREADONLY_on(sv);
}

extern char * uri_escape_unsafe; 
extern char * uri_errstr; 
#ifdef PERL_OBJECT
#define MAGIC_CLASS _wrap_URIC_var::
class _wrap_URIC_var : public CPerl {
public:
#else
#define MAGIC_CLASS
#endif
SWIGCLASS_STATIC int swig_magic_readonly(SV *sv, MAGIC *mg) {
    MAGIC_PPERL
    sv = sv; mg = mg;
    croak("Value is read-only.");
    return 0;
}
SWIGCLASS_STATIC int _wrap_set_uri_escape_unsafe(SV* sv, MAGIC *mg) {

    char *_a;

    MAGIC_PPERL
    mg = mg;
    _a = (char *) SvPV(sv,na);
    if (uri_escape_unsafe) free(uri_escape_unsafe);
    uri_escape_unsafe = (char *) malloc(strlen(_a)+1);
strcpy(uri_escape_unsafe,_a);
    return 1;
}

SWIGCLASS_STATIC int _wrap_val_uri_escape_unsafe(SV *sv, MAGIC *mg) {


    MAGIC_PPERL
    mg = mg;
    sv_setpv((SV*) sv, uri_escape_unsafe);
    return 1;
}

SWIGCLASS_STATIC int _wrap_set_uri_errstr(SV* sv, MAGIC *mg) {

    char *_a;

    MAGIC_PPERL
    mg = mg;
    _a = (char *) SvPV(sv,na);
    if (uri_errstr) free(uri_errstr);
    uri_errstr = (char *) malloc(strlen(_a)+1);
strcpy(uri_errstr,_a);
    return 1;
}

SWIGCLASS_STATIC int _wrap_val_uri_errstr(SV *sv, MAGIC *mg) {


    MAGIC_PPERL
    mg = mg;
    sv_setpv((SV*) sv, uri_errstr);
    return 1;
}



#ifdef PERL_OBJECT
};
#endif

XS(_wrap_uri_mode) {

    int  _result;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 0) || (items > 0)) 
        croak("Usage: uri_mode();");
    _result = (int )uri_mode();
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) _result);
    XSRETURN(argvi);
}

XS(_wrap_uri_mode_set) {

    int  _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: uri_mode_set(flag);");
    _arg0 = (int )SvIV(ST(0));
    uri_mode_set(_arg0);
    XSRETURN(argvi);
}

XS(_wrap_uri_modep) {

    int  _result;
    int  _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: uri_modep(flag);");
    _arg0 = (int )SvIV(ST(0));
    _result = (int )uri_modep(_arg0);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) _result);
    XSRETURN(argvi);
}

XS(_wrap_uri_alloc_1) {

    uri_t * _result;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 0) || (items > 0)) 
        croak("Usage: uri_alloc_1();");
    _result = (uri_t *)uri_alloc_1();
    ST(argvi) = sv_newmortal();
    sv_setref_pv(ST(argvi++),"uri_t", (void *) _result);
    XSRETURN(argvi);
}

XS(_wrap_uri_alloc) {

    uri_t * _result;
    char * _arg0;
    int  _arg1;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 2) || (items > 2)) 
        croak("Usage: uri_alloc(uri,uri_length);");
    _arg0 = (char *) SvPV(ST(0),na);
    _arg1 = (int )SvIV(ST(1));
    _result = (uri_t *)uri_alloc(_arg0,_arg1);
    ST(argvi) = sv_newmortal();
    sv_setref_pv(ST(argvi++),"uri_t", (void *) _result);
    XSRETURN(argvi);
}

XS(_wrap_uri_realloc) {

    int  _result;
    uri_t * _arg0;
    char * _arg1;
    int  _arg2;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 3) || (items > 3)) 
        croak("Usage: uri_realloc(object,uri,uri_length);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"uri_t")) {
        croak("Type error in argument 1 of uri_realloc. Expected uri_t.");
        XSRETURN(1);
    }
    _arg1 = (char *) SvPV(ST(1),na);
    _arg2 = (int )SvIV(ST(2));
    _result = (int )uri_realloc(_arg0,_arg1,_arg2);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) _result);
    XSRETURN(argvi);
}

XS(_wrap_uri_free) {

    uri_t * _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: uri_free(object);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"uri_t")) {
        croak("Type error in argument 1 of uri_free. Expected uri_t.");
        XSRETURN(1);
    }
    uri_free(_arg0);
    XSRETURN(argvi);
}

XS(_wrap_uri_info) {

    int  _result;
    uri_t * _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: uri_info(object);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"uri_t")) {
        croak("Type error in argument 1 of uri_info. Expected uri_t.");
        XSRETURN(1);
    }
    _result = (int )uri_info(_arg0);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) _result);
    XSRETURN(argvi);
}

XS(_wrap_uri_scheme) {

    char * _result;
    uri_t * _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: uri_scheme(object);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"uri_t")) {
        croak("Type error in argument 1 of uri_scheme. Expected uri_t.");
        XSRETURN(1);
    }
    _result = (char *)uri_scheme(_arg0);
    ST(argvi) = sv_newmortal();
    sv_setpv((SV*)ST(argvi++),(char *) _result);
    XSRETURN(argvi);
}

XS(_wrap_uri_host) {

    char * _result;
    uri_t * _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: uri_host(object);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"uri_t")) {
        croak("Type error in argument 1 of uri_host. Expected uri_t.");
        XSRETURN(1);
    }
    _result = (char *)uri_host(_arg0);
    ST(argvi) = sv_newmortal();
    sv_setpv((SV*)ST(argvi++),(char *) _result);
    XSRETURN(argvi);
}

XS(_wrap_uri_port) {

    char * _result;
    uri_t * _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: uri_port(object);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"uri_t")) {
        croak("Type error in argument 1 of uri_port. Expected uri_t.");
        XSRETURN(1);
    }
    _result = (char *)uri_port(_arg0);
    ST(argvi) = sv_newmortal();
    sv_setpv((SV*)ST(argvi++),(char *) _result);
    XSRETURN(argvi);
}

XS(_wrap_uri_path) {

    char * _result;
    uri_t * _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: uri_path(object);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"uri_t")) {
        croak("Type error in argument 1 of uri_path. Expected uri_t.");
        XSRETURN(1);
    }
    _result = (char *)uri_path(_arg0);
    ST(argvi) = sv_newmortal();
    sv_setpv((SV*)ST(argvi++),(char *) _result);
    XSRETURN(argvi);
}

XS(_wrap_uri_params) {

    char * _result;
    uri_t * _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: uri_params(object);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"uri_t")) {
        croak("Type error in argument 1 of uri_params. Expected uri_t.");
        XSRETURN(1);
    }
    _result = (char *)uri_params(_arg0);
    ST(argvi) = sv_newmortal();
    sv_setpv((SV*)ST(argvi++),(char *) _result);
    XSRETURN(argvi);
}

XS(_wrap_uri_query) {

    char * _result;
    uri_t * _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: uri_query(object);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"uri_t")) {
        croak("Type error in argument 1 of uri_query. Expected uri_t.");
        XSRETURN(1);
    }
    _result = (char *)uri_query(_arg0);
    ST(argvi) = sv_newmortal();
    sv_setpv((SV*)ST(argvi++),(char *) _result);
    XSRETURN(argvi);
}

XS(_wrap_uri_frag) {

    char * _result;
    uri_t * _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: uri_frag(object);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"uri_t")) {
        croak("Type error in argument 1 of uri_frag. Expected uri_t.");
        XSRETURN(1);
    }
    _result = (char *)uri_frag(_arg0);
    ST(argvi) = sv_newmortal();
    sv_setpv((SV*)ST(argvi++),(char *) _result);
    XSRETURN(argvi);
}

XS(_wrap_uri_user) {

    char * _result;
    uri_t * _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: uri_user(object);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"uri_t")) {
        croak("Type error in argument 1 of uri_user. Expected uri_t.");
        XSRETURN(1);
    }
    _result = (char *)uri_user(_arg0);
    ST(argvi) = sv_newmortal();
    sv_setpv((SV*)ST(argvi++),(char *) _result);
    XSRETURN(argvi);
}

XS(_wrap_uri_passwd) {

    char * _result;
    uri_t * _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: uri_passwd(object);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"uri_t")) {
        croak("Type error in argument 1 of uri_passwd. Expected uri_t.");
        XSRETURN(1);
    }
    _result = (char *)uri_passwd(_arg0);
    ST(argvi) = sv_newmortal();
    sv_setpv((SV*)ST(argvi++),(char *) _result);
    XSRETURN(argvi);
}

XS(_wrap_uri_netloc) {

    char * _result;
    uri_t * _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: uri_netloc(object);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"uri_t")) {
        croak("Type error in argument 1 of uri_netloc. Expected uri_t.");
        XSRETURN(1);
    }
    _result = (char *)uri_netloc(_arg0);
    ST(argvi) = sv_newmortal();
    sv_setpv((SV*)ST(argvi++),(char *) _result);
    XSRETURN(argvi);
}

XS(_wrap_uri_auth) {

    char * _result;
    uri_t * _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: uri_auth(object);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"uri_t")) {
        croak("Type error in argument 1 of uri_auth. Expected uri_t.");
        XSRETURN(1);
    }
    _result = (char *)uri_auth(_arg0);
    ST(argvi) = sv_newmortal();
    sv_setpv((SV*)ST(argvi++),(char *) _result);
    XSRETURN(argvi);
}

XS(_wrap_uri_auth_netloc) {

    char * _result;
    uri_t * _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: uri_auth_netloc(object);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"uri_t")) {
        croak("Type error in argument 1 of uri_auth_netloc. Expected uri_t.");
        XSRETURN(1);
    }
    _result = (char *)uri_auth_netloc(_arg0);
    ST(argvi) = sv_newmortal();
    sv_setpv((SV*)ST(argvi++),(char *) _result);
    XSRETURN(argvi);
}

XS(_wrap_uri_all_path) {

    char * _result;
    uri_t * _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: uri_all_path(object);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"uri_t")) {
        croak("Type error in argument 1 of uri_all_path. Expected uri_t.");
        XSRETURN(1);
    }
    _result = (char *)uri_all_path(_arg0);
    ST(argvi) = sv_newmortal();
    sv_setpv((SV*)ST(argvi++),(char *) _result);
    XSRETURN(argvi);
}

XS(_wrap_uri_info_set) {

    uri_t * _arg0;
    int  _arg1;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 2) || (items > 2)) 
        croak("Usage: uri_info_set(object,value);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"uri_t")) {
        croak("Type error in argument 1 of uri_info_set. Expected uri_t.");
        XSRETURN(1);
    }
    _arg1 = (int )SvIV(ST(1));
    uri_info_set(_arg0,_arg1);
    XSRETURN(argvi);
}

XS(_wrap_uri_scheme_set) {

    uri_t * _arg0;
    char * _arg1;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 2) || (items > 2)) 
        croak("Usage: uri_scheme_set(object,value);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"uri_t")) {
        croak("Type error in argument 1 of uri_scheme_set. Expected uri_t.");
        XSRETURN(1);
    }
    _arg1 = (char *) SvPV(ST(1),na);
    uri_scheme_set(_arg0,_arg1);
    XSRETURN(argvi);
}

XS(_wrap_uri_host_set) {

    uri_t * _arg0;
    char * _arg1;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 2) || (items > 2)) 
        croak("Usage: uri_host_set(object,value);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"uri_t")) {
        croak("Type error in argument 1 of uri_host_set. Expected uri_t.");
        XSRETURN(1);
    }
    _arg1 = (char *) SvPV(ST(1),na);
    uri_host_set(_arg0,_arg1);
    XSRETURN(argvi);
}

XS(_wrap_uri_port_set) {

    uri_t * _arg0;
    char * _arg1;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 2) || (items > 2)) 
        croak("Usage: uri_port_set(object,value);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"uri_t")) {
        croak("Type error in argument 1 of uri_port_set. Expected uri_t.");
        XSRETURN(1);
    }
    _arg1 = (char *) SvPV(ST(1),na);
    uri_port_set(_arg0,_arg1);
    XSRETURN(argvi);
}

XS(_wrap_uri_path_set) {

    uri_t * _arg0;
    char * _arg1;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 2) || (items > 2)) 
        croak("Usage: uri_path_set(object,value);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"uri_t")) {
        croak("Type error in argument 1 of uri_path_set. Expected uri_t.");
        XSRETURN(1);
    }
    _arg1 = (char *) SvPV(ST(1),na);
    uri_path_set(_arg0,_arg1);
    XSRETURN(argvi);
}

XS(_wrap_uri_params_set) {

    uri_t * _arg0;
    char * _arg1;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 2) || (items > 2)) 
        croak("Usage: uri_params_set(object,value);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"uri_t")) {
        croak("Type error in argument 1 of uri_params_set. Expected uri_t.");
        XSRETURN(1);
    }
    _arg1 = (char *) SvPV(ST(1),na);
    uri_params_set(_arg0,_arg1);
    XSRETURN(argvi);
}

XS(_wrap_uri_query_set) {

    uri_t * _arg0;
    char * _arg1;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 2) || (items > 2)) 
        croak("Usage: uri_query_set(object,value);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"uri_t")) {
        croak("Type error in argument 1 of uri_query_set. Expected uri_t.");
        XSRETURN(1);
    }
    _arg1 = (char *) SvPV(ST(1),na);
    uri_query_set(_arg0,_arg1);
    XSRETURN(argvi);
}

XS(_wrap_uri_frag_set) {

    uri_t * _arg0;
    char * _arg1;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 2) || (items > 2)) 
        croak("Usage: uri_frag_set(object,value);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"uri_t")) {
        croak("Type error in argument 1 of uri_frag_set. Expected uri_t.");
        XSRETURN(1);
    }
    _arg1 = (char *) SvPV(ST(1),na);
    uri_frag_set(_arg0,_arg1);
    XSRETURN(argvi);
}

XS(_wrap_uri_user_set) {

    uri_t * _arg0;
    char * _arg1;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 2) || (items > 2)) 
        croak("Usage: uri_user_set(object,value);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"uri_t")) {
        croak("Type error in argument 1 of uri_user_set. Expected uri_t.");
        XSRETURN(1);
    }
    _arg1 = (char *) SvPV(ST(1),na);
    uri_user_set(_arg0,_arg1);
    XSRETURN(argvi);
}

XS(_wrap_uri_passwd_set) {

    uri_t * _arg0;
    char * _arg1;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 2) || (items > 2)) 
        croak("Usage: uri_passwd_set(object,value);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"uri_t")) {
        croak("Type error in argument 1 of uri_passwd_set. Expected uri_t.");
        XSRETURN(1);
    }
    _arg1 = (char *) SvPV(ST(1),na);
    uri_passwd_set(_arg0,_arg1);
    XSRETURN(argvi);
}

XS(_wrap_uri_copy) {

    uri_t * _arg0;
    uri_t * _arg1;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 2) || (items > 2)) 
        croak("Usage: uri_copy(to,from);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"uri_t")) {
        croak("Type error in argument 1 of uri_copy. Expected uri_t.");
        XSRETURN(1);
    }
    if (SWIG_GetPtr(ST(1),(void **) &_arg1,"uri_t")) {
        croak("Type error in argument 2 of uri_copy. Expected uri_t.");
        XSRETURN(1);
    }
    uri_copy(_arg0,_arg1);
    XSRETURN(argvi);
}

XS(_wrap_uri_clone) {

    uri_t * _result;
    uri_t * _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: uri_clone(from);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"uri_t")) {
        croak("Type error in argument 1 of uri_clone. Expected uri_t.");
        XSRETURN(1);
    }
    _result = (uri_t *)uri_clone(_arg0);
    ST(argvi) = sv_newmortal();
    sv_setref_pv(ST(argvi++),"uri_t", (void *) _result);
    XSRETURN(argvi);
}

XS(_wrap_uri_clear) {

    uri_t * _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: uri_clear(object);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"uri_t")) {
        croak("Type error in argument 1 of uri_clear. Expected uri_t.");
        XSRETURN(1);
    }
    uri_clear(_arg0);
    XSRETURN(argvi);
}

XS(_wrap_uri_dump) {

    uri_t * _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: uri_dump(object);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"uri_t")) {
        croak("Type error in argument 1 of uri_dump. Expected uri_t.");
        XSRETURN(1);
    }
    uri_dump(_arg0);
    XSRETURN(argvi);
}

XS(_wrap_uri_furi) {

    char * _result;
    uri_t * _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: uri_furi(object);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"uri_t")) {
        croak("Type error in argument 1 of uri_furi. Expected uri_t.");
        XSRETURN(1);
    }
    _result = (char *)uri_furi(_arg0);
    ST(argvi) = sv_newmortal();
    sv_setpv((SV*)ST(argvi++),(char *) _result);
    XSRETURN(argvi);
}

XS(_wrap_uri_uri) {

    char * _result;
    uri_t * _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: uri_uri(object);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"uri_t")) {
        croak("Type error in argument 1 of uri_uri. Expected uri_t.");
        XSRETURN(1);
    }
    _result = (char *)uri_uri(_arg0);
    ST(argvi) = sv_newmortal();
    sv_setpv((SV*)ST(argvi++),(char *) _result);
    XSRETURN(argvi);
}

XS(_wrap_uri_escape) {

    char * _result;
    char * _arg0;
    char * _arg1;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 2) || (items > 2)) 
        croak("Usage: uri_escape(string,range);");
    _arg0 = (char *) SvPV(ST(0),na);
    _arg1 = (char *) SvPV(ST(1),na);
    _result = (char *)uri_escape(_arg0,_arg1);
    ST(argvi) = sv_newmortal();
    sv_setpv((SV*)ST(argvi++),(char *) _result);
    XSRETURN(argvi);
}

XS(_wrap_uri_unescape) {

    char * _result;
    char * _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: uri_unescape(string);");
    _arg0 = (char *) SvPV(ST(0),na);
    _result = (char *)uri_unescape(_arg0);
    ST(argvi) = sv_newmortal();
    sv_setpv((SV*)ST(argvi++),(char *) _result);
    XSRETURN(argvi);
}

XS(_wrap_uri_object) {

    uri_t * _result;
    char * _arg0;
    int  _arg1;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 2) || (items > 2)) 
        croak("Usage: uri_object(uri,uri_length);");
    _arg0 = (char *) SvPV(ST(0),na);
    _arg1 = (int )SvIV(ST(1));
    _result = (uri_t *)uri_object(_arg0,_arg1);
    ST(argvi) = sv_newmortal();
    sv_setref_pv(ST(argvi++),"uri_t", (void *) _result);
    XSRETURN(argvi);
}

XS(_wrap_uri_furi_string) {

    char * _result;
    char * _arg0;
    int  _arg1;
    int  _arg2;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 3) || (items > 3)) 
        croak("Usage: uri_furi_string(uri,uri_length,flag);");
    _arg0 = (char *) SvPV(ST(0),na);
    _arg1 = (int )SvIV(ST(1));
    _arg2 = (int )SvIV(ST(2));
    _result = (char *)uri_furi_string(_arg0,_arg1,_arg2);
    ST(argvi) = sv_newmortal();
    sv_setpv((SV*)ST(argvi++),(char *) _result);
    XSRETURN(argvi);
}

XS(_wrap_uri_cannonicalize_string) {

    char * _result;
    char * _arg0;
    int  _arg1;
    int  _arg2;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 3) || (items > 3)) 
        croak("Usage: uri_cannonicalize_string(uri,uri_length,flag);");
    _arg0 = (char *) SvPV(ST(0),na);
    _arg1 = (int )SvIV(ST(1));
    _arg2 = (int )SvIV(ST(2));
    _result = (char *)uri_cannonicalize_string(_arg0,_arg1,_arg2);
    ST(argvi) = sv_newmortal();
    sv_setpv((SV*)ST(argvi++),(char *) _result);
    XSRETURN(argvi);
}

XS(_wrap_uri_cannonicalize) {

    int  _result;
    uri_t * _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: uri_cannonicalize(object);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"uri_t")) {
        croak("Type error in argument 1 of uri_cannonicalize. Expected uri_t.");
        XSRETURN(1);
    }
    _result = (int )uri_cannonicalize(_arg0);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) _result);
    XSRETURN(argvi);
}

XS(_wrap_uri_cannonical) {

    uri_t * _result;
    uri_t * _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: uri_cannonical(object);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"uri_t")) {
        croak("Type error in argument 1 of uri_cannonical. Expected uri_t.");
        XSRETURN(1);
    }
    _result = (uri_t *)uri_cannonical(_arg0);
    ST(argvi) = sv_newmortal();
    sv_setref_pv(ST(argvi++),"uri_t", (void *) _result);
    XSRETURN(argvi);
}

XS(_wrap_uri_parse) {

    int  _result;
    uri_t * _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: uri_parse(object);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"uri_t")) {
        croak("Type error in argument 1 of uri_parse. Expected uri_t.");
        XSRETURN(1);
    }
    _result = (int )uri_parse(_arg0);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) _result);
    XSRETURN(argvi);
}

XS(_wrap_uri_scheme_switch) {

    int  _result;
    uri_t * _arg0;
    char * _arg1;
    int  _arg2;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 3) || (items > 3)) 
        croak("Usage: uri_scheme_switch(object,scheme,scheme_length);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"uri_t")) {
        croak("Type error in argument 1 of uri_scheme_switch. Expected uri_t.");
        XSRETURN(1);
    }
    _arg1 = (char *) SvPV(ST(1),na);
    _arg2 = (int )SvIV(ST(2));
    _result = (int )uri_scheme_switch(_arg0,_arg1,_arg2);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) _result);
    XSRETURN(argvi);
}

XS(_wrap_uri_consistent) {

    int  _result;
    uri_t * _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: uri_consistent(object);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"uri_t")) {
        croak("Type error in argument 1 of uri_consistent. Expected uri_t.");
        XSRETURN(1);
    }
    _result = (int )uri_consistent(_arg0);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) _result);
    XSRETURN(argvi);
}

XS(_wrap_uri_abs) {

    uri_t * _result;
    uri_t * _arg0;
    char * _arg1;
    int  _arg2;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 3) || (items > 3)) 
        croak("Usage: uri_abs(base,relative_string,relative_length);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"uri_t")) {
        croak("Type error in argument 1 of uri_abs. Expected uri_t.");
        XSRETURN(1);
    }
    _arg1 = (char *) SvPV(ST(1),na);
    _arg2 = (int )SvIV(ST(2));
    _result = (uri_t *)uri_abs(_arg0,_arg1,_arg2);
    ST(argvi) = sv_newmortal();
    sv_setref_pv(ST(argvi++),"uri_t", (void *) _result);
    XSRETURN(argvi);
}

XS(_wrap_uri_abs_1) {

    uri_t * _result;
    uri_t * _arg0;
    uri_t * _arg1;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 2) || (items > 2)) 
        croak("Usage: uri_abs_1(base,relative);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"uri_t")) {
        croak("Type error in argument 1 of uri_abs_1. Expected uri_t.");
        XSRETURN(1);
    }
    if (SWIG_GetPtr(ST(1),(void **) &_arg1,"uri_t")) {
        croak("Type error in argument 2 of uri_abs_1. Expected uri_t.");
        XSRETURN(1);
    }
    _result = (uri_t *)uri_abs_1(_arg0,_arg1);
    ST(argvi) = sv_newmortal();
    sv_setref_pv(ST(argvi++),"uri_t", (void *) _result);
    XSRETURN(argvi);
}

XS(_wrap_uri_robots) {

    char * _result;
    uri_t * _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: uri_robots(object);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"uri_t")) {
        croak("Type error in argument 1 of uri_robots. Expected uri_t.");
        XSRETURN(1);
    }
    _result = (char *)uri_robots(_arg0);
    ST(argvi) = sv_newmortal();
    sv_setpv((SV*)ST(argvi++),(char *) _result);
    XSRETURN(argvi);
}

XS(_wrap_uri_gopher_type) {

    char * _result;
    uri_t * _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: uri_gopher_type(object);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"uri_t")) {
        croak("Type error in argument 1 of uri_gopher_type. Expected uri_t.");
        XSRETURN(1);
    }
    _result = (char *)uri_gopher_type(_arg0);
    ST(argvi) = sv_newmortal();
    sv_setpv((SV*)ST(argvi++),(char *) _result);
    XSRETURN(argvi);
}

XS(_wrap_uri_gopher_selector) {

    char * _result;
    uri_t * _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: uri_gopher_selector(object);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"uri_t")) {
        croak("Type error in argument 1 of uri_gopher_selector. Expected uri_t.");
        XSRETURN(1);
    }
    _result = (char *)uri_gopher_selector(_arg0);
    ST(argvi) = sv_newmortal();
    sv_setpv((SV*)ST(argvi++),(char *) _result);
    XSRETURN(argvi);
}

XS(_wrap_uri_gopher_search) {

    char * _result;
    uri_t * _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: uri_gopher_search(object);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"uri_t")) {
        croak("Type error in argument 1 of uri_gopher_search. Expected uri_t.");
        XSRETURN(1);
    }
    _result = (char *)uri_gopher_search(_arg0);
    ST(argvi) = sv_newmortal();
    sv_setpv((SV*)ST(argvi++),(char *) _result);
    XSRETURN(argvi);
}

XS(_wrap_uri_gopher_string) {

    char * _result;
    uri_t * _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: uri_gopher_string(object);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"uri_t")) {
        croak("Type error in argument 1 of uri_gopher_string. Expected uri_t.");
        XSRETURN(1);
    }
    _result = (char *)uri_gopher_string(_arg0);
    ST(argvi) = sv_newmortal();
    sv_setpv((SV*)ST(argvi++),(char *) _result);
    XSRETURN(argvi);
}

XS(_wrap_uri_gopher_type_set) {

    uri_t * _arg0;
    char * _arg1;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 2) || (items > 2)) 
        croak("Usage: uri_gopher_type_set(object,value);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"uri_t")) {
        croak("Type error in argument 1 of uri_gopher_type_set. Expected uri_t.");
        XSRETURN(1);
    }
    _arg1 = (char *) SvPV(ST(1),na);
    uri_gopher_type_set(_arg0,_arg1);
    XSRETURN(argvi);
}

XS(_wrap_uri_gopher_selector_set) {

    uri_t * _arg0;
    char * _arg1;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 2) || (items > 2)) 
        croak("Usage: uri_gopher_selector_set(object,value);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"uri_t")) {
        croak("Type error in argument 1 of uri_gopher_selector_set. Expected uri_t.");
        XSRETURN(1);
    }
    _arg1 = (char *) SvPV(ST(1),na);
    uri_gopher_selector_set(_arg0,_arg1);
    XSRETURN(argvi);
}

XS(_wrap_uri_gopher_search_set) {

    uri_t * _arg0;
    char * _arg1;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 2) || (items > 2)) 
        croak("Usage: uri_gopher_search_set(object,value);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"uri_t")) {
        croak("Type error in argument 1 of uri_gopher_search_set. Expected uri_t.");
        XSRETURN(1);
    }
    _arg1 = (char *) SvPV(ST(1),na);
    uri_gopher_search_set(_arg0,_arg1);
    XSRETURN(argvi);
}

XS(_wrap_uri_gopher_string_set) {

    uri_t * _arg0;
    char * _arg1;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 2) || (items > 2)) 
        croak("Usage: uri_gopher_string_set(object,value);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"uri_t")) {
        croak("Type error in argument 1 of uri_gopher_string_set. Expected uri_t.");
        XSRETURN(1);
    }
    _arg1 = (char *) SvPV(ST(1),na);
    uri_gopher_string_set(_arg0,_arg1);
    XSRETURN(argvi);
}

XS(_wrap_uri_nntp_group) {

    char * _result;
    uri_t * _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: uri_nntp_group(object);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"uri_t")) {
        croak("Type error in argument 1 of uri_nntp_group. Expected uri_t.");
        XSRETURN(1);
    }
    _result = (char *)uri_nntp_group(_arg0);
    ST(argvi) = sv_newmortal();
    sv_setpv((SV*)ST(argvi++),(char *) _result);
    XSRETURN(argvi);
}

XS(_wrap_uri_nntp_article) {

    char * _result;
    uri_t * _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: uri_nntp_article(object);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"uri_t")) {
        croak("Type error in argument 1 of uri_nntp_article. Expected uri_t.");
        XSRETURN(1);
    }
    _result = (char *)uri_nntp_article(_arg0);
    ST(argvi) = sv_newmortal();
    sv_setpv((SV*)ST(argvi++),(char *) _result);
    XSRETURN(argvi);
}

XS(_wrap_uri_nntp_group_set) {

    uri_t * _arg0;
    char * _arg1;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 2) || (items > 2)) 
        croak("Usage: uri_nntp_group_set(object,value);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"uri_t")) {
        croak("Type error in argument 1 of uri_nntp_group_set. Expected uri_t.");
        XSRETURN(1);
    }
    _arg1 = (char *) SvPV(ST(1),na);
    uri_nntp_group_set(_arg0,_arg1);
    XSRETURN(argvi);
}

XS(_wrap_uri_nntp_article_set) {

    uri_t * _arg0;
    char * _arg1;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 2) || (items > 2)) 
        croak("Usage: uri_nntp_article_set(object,value);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"uri_t")) {
        croak("Type error in argument 1 of uri_nntp_article_set. Expected uri_t.");
        XSRETURN(1);
    }
    _arg1 = (char *) SvPV(ST(1),na);
    uri_nntp_article_set(_arg0,_arg1);
    XSRETURN(argvi);
}

XS(_wrap_uri_wais_database) {

    char * _result;
    uri_t * _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: uri_wais_database(object);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"uri_t")) {
        croak("Type error in argument 1 of uri_wais_database. Expected uri_t.");
        XSRETURN(1);
    }
    _result = (char *)uri_wais_database(_arg0);
    ST(argvi) = sv_newmortal();
    sv_setpv((SV*)ST(argvi++),(char *) _result);
    XSRETURN(argvi);
}

XS(_wrap_uri_wais_wtype) {

    char * _result;
    uri_t * _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: uri_wais_wtype(object);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"uri_t")) {
        croak("Type error in argument 1 of uri_wais_wtype. Expected uri_t.");
        XSRETURN(1);
    }
    _result = (char *)uri_wais_wtype(_arg0);
    ST(argvi) = sv_newmortal();
    sv_setpv((SV*)ST(argvi++),(char *) _result);
    XSRETURN(argvi);
}

XS(_wrap_uri_wais_wpath) {

    char * _result;
    uri_t * _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: uri_wais_wpath(object);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"uri_t")) {
        croak("Type error in argument 1 of uri_wais_wpath. Expected uri_t.");
        XSRETURN(1);
    }
    _result = (char *)uri_wais_wpath(_arg0);
    ST(argvi) = sv_newmortal();
    sv_setpv((SV*)ST(argvi++),(char *) _result);
    XSRETURN(argvi);
}

XS(_wrap_uri_wais_database_set) {

    uri_t * _arg0;
    char * _arg1;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 2) || (items > 2)) 
        croak("Usage: uri_wais_database_set(object,value);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"uri_t")) {
        croak("Type error in argument 1 of uri_wais_database_set. Expected uri_t.");
        XSRETURN(1);
    }
    _arg1 = (char *) SvPV(ST(1),na);
    uri_wais_database_set(_arg0,_arg1);
    XSRETURN(argvi);
}

XS(_wrap_uri_wais_wtype_set) {

    uri_t * _arg0;
    char * _arg1;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 2) || (items > 2)) 
        croak("Usage: uri_wais_wtype_set(object,value);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"uri_t")) {
        croak("Type error in argument 1 of uri_wais_wtype_set. Expected uri_t.");
        XSRETURN(1);
    }
    _arg1 = (char *) SvPV(ST(1),na);
    uri_wais_wtype_set(_arg0,_arg1);
    XSRETURN(argvi);
}

XS(_wrap_uri_wais_wpath_set) {

    uri_t * _arg0;
    char * _arg1;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 2) || (items > 2)) 
        croak("Usage: uri_wais_wpath_set(object,value);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"uri_t")) {
        croak("Type error in argument 1 of uri_wais_wpath_set. Expected uri_t.");
        XSRETURN(1);
    }
    _arg1 = (char *) SvPV(ST(1),na);
    uri_wais_wpath_set(_arg0,_arg1);
    XSRETURN(argvi);
}

XS(_wrap_perl5_URIC_var_init) {
    dXSARGS;
    SV *sv;
    cv = cv; items = items;
    swig_setiv("URI_MODE_CANNONICAL", (long) 0x0001);
    swig_setiv("URI_MODE_LOWER_SCHEME", (long) 0x0002);
    swig_setiv("URI_MODE_ERROR_STDERR", (long) 0x0004);
    swig_setiv("URI_MODE_FIELD_MALLOC", (long) 0x0008);
    swig_setiv("URI_MODE_URI_STRICT", (long) 0x0010);
    swig_setiv("URI_MODE_URI_STRICT_SCHEME", (long) 0x0020);
    swig_setiv("URI_MODE_FLAG_DEFAULT", (long) ((0x0001)|(0x0004)));
    swig_setiv("URI_MODE_FLAG_NONE", (long) 0);
    swig_setiv("URI_INFO_CANNONICAL", (long) 0x00000001);
    swig_setiv("URI_INFO_URI", (long) 0x00000002);
    swig_setiv("URI_INFO_FURI", (long) 0x00000004);
    swig_setiv("URI_INFO_RELATIVE", (long) 0x00000008);
    swig_setiv("URI_INFO_RELATIVE_PATH", (long) 0x00000010);
    swig_setiv("URI_INFO_EMPTY", (long) 0x00000020);
    swig_setiv("URI_INFO_PARSED", (long) 0x00000040);
    swig_setiv("URI_INFO_ROBOTS", (long) 0x00000080);
    swig_setiv("URI_INFO_M_SCHEME", (long) 0x00000100);
    swig_setiv("URI_INFO_M_HOST", (long) 0x00000200);
    swig_setiv("URI_INFO_M_PORT", (long) 0x00000400);
    swig_setiv("URI_INFO_M_PATH", (long) 0x00000800);
    swig_setiv("URI_INFO_M_PARAMS", (long) 0x00001000);
    swig_setiv("URI_INFO_M_QUERY", (long) 0x00002000);
    swig_setiv("URI_INFO_M_FRAG", (long) 0x00004000);
    swig_setiv("URI_INFO_M_USER", (long) 0x00008000);
    swig_setiv("URI_INFO_M_PASSWD", (long) 0x00010000);
    swig_setiv("URI_INFO_FIELD_CHANGED", (long) 0x00020000);
    swig_setiv("URI_INFO_CANNONICAL_OK", (long) 0x00040000);
    swig_setiv("URI_INFO_PARSE_MASK", (long) 0x00000038);
    swig_setiv("URI_INFO_CACHE_MASK", (long) 0x00040087);
    swig_setiv("URI_INFO_M_MASK", (long) 0x0003ff00);
    swig_setiv("URI_INFO_COPY_MASK", (long) ((0x00040087)|(0x0003ff00)));
    swig_setpv("URI_ESCAPE_RESERVED", ";\\/?:@&=+#%");
    swig_setpv("URI_ESCAPE_PATH", ";\\?:@&=+#%");
    swig_setpv("URI_ESCAPE_QUERY", ";\\/?:@+#%");
    sv = perl_get_sv("uri_escape_unsafe",TRUE | 0x2);
    swig_create_magic(sv,"uri_escape_unsafe", MAGIC_CAST MAGIC_CLASS _wrap_set_uri_escape_unsafe, MAGIC_CAST MAGIC_CLASS _wrap_val_uri_escape_unsafe);
    swig_setiv("URI_FURI_REAL_PATH", (long) 1);
    swig_setiv("URI_FURI_NOP", (long) 0);
    swig_setiv("URI_STRING_FURI_STYLE", (long) 0x01);
    swig_setiv("URI_STRING_URI_STYLE", (long) 0x02);
    swig_setiv("URI_STRING_ROBOTS_STYLE", (long) 0x04);
    swig_setiv("URI_STRING_URI_NOHASH_STYLE", (long) 0x08);
    sv = perl_get_sv("uri_errstr",TRUE | 0x2);
    swig_create_magic(sv,"uri_errstr", MAGIC_CAST MAGIC_CLASS _wrap_set_uri_errstr, MAGIC_CAST MAGIC_CLASS _wrap_val_uri_errstr);
    swig_setiv("URI_NOT_CANNONICAL", (long) -1);
    swig_setiv("URI_CANNONICAL", (long) 0);
    XSRETURN(1);
}
#ifdef __cplusplus
extern "C"
#endif
XS(boot_URIC) {
	 dXSARGS;
	 char *file = __FILE__;
	 cv = cv; items = items;
	 newXS("URICc::var_URIC_init", _wrap_perl5_URIC_var_init, file);
	 newXS("URICc::uri_mode", _wrap_uri_mode, file);
	 newXS("URICc::uri_mode_set", _wrap_uri_mode_set, file);
	 newXS("URICc::uri_modep", _wrap_uri_modep, file);
	 newXS("URICc::uri_alloc_1", _wrap_uri_alloc_1, file);
	 newXS("URICc::uri_alloc", _wrap_uri_alloc, file);
	 newXS("URICc::uri_realloc", _wrap_uri_realloc, file);
	 newXS("URICc::uri_free", _wrap_uri_free, file);
	 newXS("URICc::uri_info", _wrap_uri_info, file);
	 newXS("URICc::uri_scheme", _wrap_uri_scheme, file);
	 newXS("URICc::uri_host", _wrap_uri_host, file);
	 newXS("URICc::uri_port", _wrap_uri_port, file);
	 newXS("URICc::uri_path", _wrap_uri_path, file);
	 newXS("URICc::uri_params", _wrap_uri_params, file);
	 newXS("URICc::uri_query", _wrap_uri_query, file);
	 newXS("URICc::uri_frag", _wrap_uri_frag, file);
	 newXS("URICc::uri_user", _wrap_uri_user, file);
	 newXS("URICc::uri_passwd", _wrap_uri_passwd, file);
	 newXS("URICc::uri_netloc", _wrap_uri_netloc, file);
	 newXS("URICc::uri_auth", _wrap_uri_auth, file);
	 newXS("URICc::uri_auth_netloc", _wrap_uri_auth_netloc, file);
	 newXS("URICc::uri_all_path", _wrap_uri_all_path, file);
	 newXS("URICc::uri_info_set", _wrap_uri_info_set, file);
	 newXS("URICc::uri_scheme_set", _wrap_uri_scheme_set, file);
	 newXS("URICc::uri_host_set", _wrap_uri_host_set, file);
	 newXS("URICc::uri_port_set", _wrap_uri_port_set, file);
	 newXS("URICc::uri_path_set", _wrap_uri_path_set, file);
	 newXS("URICc::uri_params_set", _wrap_uri_params_set, file);
	 newXS("URICc::uri_query_set", _wrap_uri_query_set, file);
	 newXS("URICc::uri_frag_set", _wrap_uri_frag_set, file);
	 newXS("URICc::uri_user_set", _wrap_uri_user_set, file);
	 newXS("URICc::uri_passwd_set", _wrap_uri_passwd_set, file);
	 newXS("URICc::uri_copy", _wrap_uri_copy, file);
	 newXS("URICc::uri_clone", _wrap_uri_clone, file);
	 newXS("URICc::uri_clear", _wrap_uri_clear, file);
	 newXS("URICc::uri_dump", _wrap_uri_dump, file);
	 newXS("URICc::uri_furi", _wrap_uri_furi, file);
	 newXS("URICc::uri_uri", _wrap_uri_uri, file);
	 newXS("URICc::uri_escape", _wrap_uri_escape, file);
	 newXS("URICc::uri_unescape", _wrap_uri_unescape, file);
	 newXS("URICc::uri_object", _wrap_uri_object, file);
	 newXS("URICc::uri_furi_string", _wrap_uri_furi_string, file);
	 newXS("URICc::uri_cannonicalize_string", _wrap_uri_cannonicalize_string, file);
	 newXS("URICc::uri_cannonicalize", _wrap_uri_cannonicalize, file);
	 newXS("URICc::uri_cannonical", _wrap_uri_cannonical, file);
	 newXS("URICc::uri_parse", _wrap_uri_parse, file);
	 newXS("URICc::uri_scheme_switch", _wrap_uri_scheme_switch, file);
	 newXS("URICc::uri_consistent", _wrap_uri_consistent, file);
	 newXS("URICc::uri_abs", _wrap_uri_abs, file);
	 newXS("URICc::uri_abs_1", _wrap_uri_abs_1, file);
	 newXS("URICc::uri_robots", _wrap_uri_robots, file);
	 newXS("URICc::uri_gopher_type", _wrap_uri_gopher_type, file);
	 newXS("URICc::uri_gopher_selector", _wrap_uri_gopher_selector, file);
	 newXS("URICc::uri_gopher_search", _wrap_uri_gopher_search, file);
	 newXS("URICc::uri_gopher_string", _wrap_uri_gopher_string, file);
	 newXS("URICc::uri_gopher_type_set", _wrap_uri_gopher_type_set, file);
	 newXS("URICc::uri_gopher_selector_set", _wrap_uri_gopher_selector_set, file);
	 newXS("URICc::uri_gopher_search_set", _wrap_uri_gopher_search_set, file);
	 newXS("URICc::uri_gopher_string_set", _wrap_uri_gopher_string_set, file);
	 newXS("URICc::uri_nntp_group", _wrap_uri_nntp_group, file);
	 newXS("URICc::uri_nntp_article", _wrap_uri_nntp_article, file);
	 newXS("URICc::uri_nntp_group_set", _wrap_uri_nntp_group_set, file);
	 newXS("URICc::uri_nntp_article_set", _wrap_uri_nntp_article_set, file);
	 newXS("URICc::uri_wais_database", _wrap_uri_wais_database, file);
	 newXS("URICc::uri_wais_wtype", _wrap_uri_wais_wtype, file);
	 newXS("URICc::uri_wais_wpath", _wrap_uri_wais_wpath, file);
	 newXS("URICc::uri_wais_database_set", _wrap_uri_wais_database_set, file);
	 newXS("URICc::uri_wais_wtype_set", _wrap_uri_wais_wtype_set, file);
	 newXS("URICc::uri_wais_wpath_set", _wrap_uri_wais_wpath_set, file);
/*
 * These are the pointer type-equivalency mappings. 
 * (Used by the SWIG pointer type-checker).
 */
	 SWIG_RegisterMapping("unsigned short","short",0);
	 SWIG_RegisterMapping("uri","uri_t",0);
	 SWIG_RegisterMapping("uri","struct uri",0);
	 SWIG_RegisterMapping("long","unsigned long",0);
	 SWIG_RegisterMapping("long","signed long",0);
	 SWIG_RegisterMapping("signed short","short",0);
	 SWIG_RegisterMapping("signed int","int",0);
	 SWIG_RegisterMapping("short","unsigned short",0);
	 SWIG_RegisterMapping("short","signed short",0);
	 SWIG_RegisterMapping("unsigned long","long",0);
	 SWIG_RegisterMapping("uri_t","struct uri",0);
	 SWIG_RegisterMapping("uri_t","uri",0);
	 SWIG_RegisterMapping("int","unsigned int",0);
	 SWIG_RegisterMapping("int","signed int",0);
	 SWIG_RegisterMapping("unsigned int","int",0);
	 SWIG_RegisterMapping("struct uri","uri_t",0);
	 SWIG_RegisterMapping("struct uri","uri",0);
	 SWIG_RegisterMapping("signed long","long",0);
	 ST(0) = &sv_yes;
	 XSRETURN(1);
}
