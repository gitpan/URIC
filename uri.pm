# This file was automatically generated by SWIG
package uri;
require Exporter;
require DynaLoader;
@ISA = qw(Exporter DynaLoader);

@EXPORT = qw( 

$URI_MODE_CANNONICAL
$URI_MODE_ERROR_STDERR
$URI_MODE_FLAG_DEFAULT
$URI_INFO_CANNONICAL
$URI_INFO_URI
$URI_INFO_FURI
$URI_INFO_RELATIVE
$URI_INFO_RELATIVE_PATH
$URI_INFO_EMPTY
$URI_INFO_PARSED
$URI_INFO_FILE
$URI_INFO_ROBOTS
$URI_FURI_REAL_PATH
$URI_FURI_NOP
$URI_STRING_FURI_STYLE
$URI_STRING_URI_STYLE
$URI_STRING_ROBOTS_STYLE
$URI_STRING_URI_NOHASH_STYLE
$uri_errstr
$URI_NOT_CANNONICAL
$URI_CANNONICAL
$URI_CANNONICALIZE_TEST
$URI_CANNONICALIZE_TRANSFORM

uri_mode
uri_port
uri_alloc
uri_realloc
uri_cannonicalize
uri_abs
uri_netloc
uri_auth
uri_all_path
uri_copy
uri_free
uri_parse
uri_dump
uri_furi
uri_uri
uri_robots
uri2object
uri_cannonicalize_string

 );

package uric;
bootstrap uri;
var_uri_init();

# ---------- BASE METHODS -------------

package uri;

sub TIEHASH {
    my ($classname,$obj) = @_;
    return bless $obj, $classname;
}

sub CLEAR { }

sub this {
    my $ptr = shift;
    return tied(%$ptr);
}


# ------- FUNCTION WRAPPERS --------

package uri;

*uri_mode = *uric::uri_mode;
*uri_modep = *uric::uri_modep;
sub uri_alloc {
    my @args = @_;
    my $result = uric::uri_alloc(@args);
    return undef if (!defined($result));
    my %resulthash;
    tie %resulthash, "uri_t", $result;
    return bless \%resulthash, "uri_t";
}
sub uri_realloc {
    my @args = @_;
    $args[0] = tied(%{$args[0]});
    my $result = uric::uri_realloc(@args);
    return $result;
}
sub uri_free {
    my @args = @_;
    $args[0] = tied(%{$args[0]});
    my $result = uric::uri_free(@args);
    return $result;
}
sub uri_abs {
    my @args = @_;
    $args[0] = tied(%{$args[0]});
    my $result = uric::uri_abs(@args);
    return undef if (!defined($result));
    my %resulthash;
    tie %resulthash, "uri_t", $result;
    return bless \%resulthash, "uri_t";
}
sub uri_abs_1 {
    my @args = @_;
    $args[0] = tied(%{$args[0]});
    $args[1] = tied(%{$args[1]});
    my $result = uric::uri_abs_1(@args);
    return undef if (!defined($result));
    my %resulthash;
    tie %resulthash, "uri_t", $result;
    return bless \%resulthash, "uri_t";
}
sub uri_port {
    my @args = @_;
    $args[0] = tied(%{$args[0]});
    my $result = uric::uri_port(@args);
    return $result;
}
sub uri_netloc {
    my @args = @_;
    $args[0] = tied(%{$args[0]});
    my $result = uric::uri_netloc(@args);
    return $result;
}
sub uri_auth {
    my @args = @_;
    $args[0] = tied(%{$args[0]});
    my $result = uric::uri_auth(@args);
    return $result;
}
sub uri_all_path {
    my @args = @_;
    $args[0] = tied(%{$args[0]});
    my $result = uric::uri_all_path(@args);
    return $result;
}
sub uri_copy {
    my @args = @_;
    $args[0] = tied(%{$args[0]});
    $args[1] = tied(%{$args[1]});
    my $result = uric::uri_copy(@args);
    return $result;
}
sub uri_dump {
    my @args = @_;
    $args[0] = tied(%{$args[0]});
    my $result = uric::uri_dump(@args);
    return $result;
}
sub uri_furi {
    my @args = @_;
    $args[0] = tied(%{$args[0]});
    my $result = uric::uri_furi(@args);
    return $result;
}
sub uri_uri {
    my @args = @_;
    $args[0] = tied(%{$args[0]});
    my $result = uric::uri_uri(@args);
    return $result;
}
sub uri_robots {
    my @args = @_;
    $args[0] = tied(%{$args[0]});
    my $result = uric::uri_robots(@args);
    return $result;
}
sub uri2object {
    my @args = @_;
    my $result = uric::uri2object(@args);
    return undef if (!defined($result));
    my %resulthash;
    tie %resulthash, "uri_t", $result;
    return bless \%resulthash, "uri_t";
}
*uri_furi_string = *uric::uri_furi_string;
*uri_cannonicalize_string = *uric::uri_cannonicalize_string;
sub uri_cannonicalize {
    my @args = @_;
    $args[0] = tied(%{$args[0]});
    my $result = uric::uri_cannonicalize(@args);
    return $result;
}
sub uri_parse {
    my @args = @_;
    $args[0] = tied(%{$args[0]});
    my $result = uric::uri_parse(@args);
    return $result;
}

############# Class : uri_t ##############

package uri_t;
@ISA = qw( uri );
%OWNER = ();
%BLESSEDMEMBERS = (
    desc => 'uri_scheme_desc',
);

%ITERATORS = ();
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
    };

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
    };

sub FETCH {
    my ($self,$field) = @_;
    my $member_func = "uric::uri_t_${field}_get";
    my $val = &$member_func($self);
    if (exists $BLESSEDMEMBERS{$field}) {
        return undef if (!defined($val));
        my %retval;
        tie %retval,$BLESSEDMEMBERS{$field},$val;
        return bless \%retval, $BLESSEDMEMBERS{$field};
    }
    return $val;
}

sub STORE {
    my ($self,$field,$newval) = @_;
    my $member_func = "uric::uri_t_${field}_set";
    if (exists $BLESSEDMEMBERS{$field}) {
        &$member_func($self,tied(%{$newval}));
    } else {
        &$member_func($self,$newval);
    }
}

sub FIRSTKEY {
    my $self = shift;
    $ITERATORS{$self} = ['info', 'scheme', 'host', 'port', 'path', 'params', 'query', 'frag', 'user', 'passwd', 'pool', 'pool_size', 'furi', 'furi_size', 'uri', 'uri_size', 'robots', 'robots_size', 'desc', ];
    my $first = shift @{$ITERATORS{$self}};
    return $first;
}

sub NEXTKEY {
    my $self = shift;
    $nelem = scalar @{$ITERATORS{$self}};
    if ($nelem > 0) {
        my $member = shift @{$ITERATORS{$self}};
        return $member;
    } else {
        $ITERATORS{$self} = ['info', 'scheme', 'host', 'port', 'path', 'params', 'query', 'frag', 'user', 'passwd', 'pool', 'pool_size', 'furi', 'furi_size', 'uri', 'uri_size', 'robots', 'robots_size', 'desc', ];
        return ();
    }
}


# ------- VARIABLE STUBS --------

package uri;

*URI_MODE_CANNONICAL = *uric::URI_MODE_CANNONICAL;
*URI_MODE_ERROR_STDERR = *uric::URI_MODE_ERROR_STDERR;
*URI_MODE_FLAG_DEFAULT = *uric::URI_MODE_FLAG_DEFAULT;
*URI_INFO_CANNONICAL = *uric::URI_INFO_CANNONICAL;
*URI_INFO_URI = *uric::URI_INFO_URI;
*URI_INFO_FURI = *uric::URI_INFO_FURI;
*URI_INFO_RELATIVE = *uric::URI_INFO_RELATIVE;
*URI_INFO_RELATIVE_PATH = *uric::URI_INFO_RELATIVE_PATH;
*URI_INFO_EMPTY = *uric::URI_INFO_EMPTY;
*URI_INFO_PARSED = *uric::URI_INFO_PARSED;
*URI_INFO_FILE = *uric::URI_INFO_FILE;
*URI_INFO_ROBOTS = *uric::URI_INFO_ROBOTS;
*URI_FURI_REAL_PATH = *uric::URI_FURI_REAL_PATH;
*URI_FURI_NOP = *uric::URI_FURI_NOP;
*URI_STRING_FURI_STYLE = *uric::URI_STRING_FURI_STYLE;
*URI_STRING_URI_STYLE = *uric::URI_STRING_URI_STYLE;
*URI_STRING_ROBOTS_STYLE = *uric::URI_STRING_ROBOTS_STYLE;
*URI_STRING_URI_NOHASH_STYLE = *uric::URI_STRING_URI_NOHASH_STYLE;
*uri_errstr = *uric::uri_errstr;
*URI_NOT_CANNONICAL = *uric::URI_NOT_CANNONICAL;
*URI_CANNONICAL = *uric::URI_CANNONICAL;
*URI_CANNONICALIZE_TEST = *uric::URI_CANNONICALIZE_TEST;
*URI_CANNONICALIZE_TRANSFORM = *uric::URI_CANNONICALIZE_TRANSFORM;
1;
